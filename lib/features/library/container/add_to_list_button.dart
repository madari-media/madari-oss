import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:logging/logging.dart';
import 'package:madari_engine/madari_engine.dart';

import '../../pocketbase/service/pocketbase.service.dart';

class AddToListButton extends StatefulWidget {
  final Meta meta;
  final Widget? child;
  final IconData? icon;
  final bool useDialog;
  final Function()? onAdded;
  final Function()? onRemoved;
  final String? listName;
  final Widget? label;
  final bool minimal;

  const AddToListButton({
    super.key,
    required this.meta,
    this.child,
    this.icon,
    this.useDialog = false,
    this.onAdded,
    this.onRemoved,
    this.listName,
    this.label,
    this.minimal = false,
  }) : assert(
          listName != null || child != null || icon != null,
          'Either listName, child, or icon must be provided',
        );

  @override
  State<AddToListButton> createState() => _AddToListButtonState();
}

class _AddToListButtonState extends State<AddToListButton> {
  final _logger = Logger('AddToListButton');
  List<ListModel> _lists = [];
  bool _isLoading = false;
  bool _existsInList = false;
  String? _existingItemId;
  ListModel? _existingList;

  @override
  void initState() {
    super.initState();
    if (widget.listName != null) {
      _checkIfExists();
    }
  }

  Future<void> _checkIfExists() async {
    try {
      setState(() => _isLoading = true);

      final lists =
          await AppPocketBaseService.instance.engine.listService.getLists();
      _existingList = lists.cast<ListModel?>().firstWhere(
            (list) =>
                list?.name.toLowerCase() == widget.listName?.toLowerCase(),
            orElse: () => null,
          );

      if (_existingList != null) {
        final items = await AppPocketBaseService.instance.engine.listService
            .getListItems(_existingList!.id);
        final existingItem = items.cast<ListItemModel?>().firstWhere(
              (item) => item?.imdbId == widget.meta.imdbId,
              orElse: () => null,
            );

        setState(() {
          _existsInList = existingItem != null;
          _existingItemId = existingItem?.id;
          _isLoading = false;
        });
      } else {
        setState(() => _isLoading = false);
      }
    } catch (e) {
      _logger.severe('Error checking if item exists', e);
      setState(() => _isLoading = false);
    }
  }

  Future<void> _loadLists() async {
    try {
      setState(() => _isLoading = true);
      _lists =
          await AppPocketBaseService.instance.engine.listService.getLists();
      setState(() => _isLoading = false);
    } catch (e) {
      _logger.severe('Error loading lists', e);
      setState(() => _isLoading = false);
    }
  }

  Future<void> _createAndAddToList(
      BuildContext context, String listName) async {
    try {
      setState(() => _isLoading = true);

      final lists =
          await AppPocketBaseService.instance.engine.listService.getLists();
      ListModel? list = lists.cast<ListModel?>().firstWhere(
            (list) => list?.name.toLowerCase() == listName.toLowerCase(),
            orElse: () => null,
          );

      if (list == null) {
        final request = CreateListRequest(
          name: listName,
          description: '',
        );
        await AppPocketBaseService.instance.engine.listService
            .createList(request);

        final updatedLists =
            await AppPocketBaseService.instance.engine.listService.getLists();
        list = updatedLists.firstWhere(
          (l) => l.name.toLowerCase() == listName.toLowerCase(),
        );
      }

      if (!context.mounted) return;

      await _addToList(context, list);
      setState(() => _isLoading = false);
      await _checkIfExists();
    } catch (e) {
      _logger.severe('Error creating/adding to list', e);
      setState(() => _isLoading = false);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to add to list'),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  Future<void> _addToList(BuildContext context, ListModel list) async {
    try {
      final item = ListItemModel(
        id: '', // Will be generated by PocketBase
        type: widget.meta.type,
        imdbId: widget.meta.imdbId ?? '',
        ids: {
          'imdb': widget.meta.imdbId,
          'tmdb': widget.meta.moviedbId?.toString(),
          'tvdb': widget.meta.tvdbId?.toString(),
        },
        title: widget.meta.name ?? '',
        description: widget.meta.description ?? '',
        poster: widget.meta.poster ?? '',
        rating: (double.tryParse((widget.meta.imdbRating_).toString()))
                ?.toDouble() ??
            0.0,
      );

      await AppPocketBaseService.instance.engine.listService
          .addListItem(list.id, item);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Added to ${list.name}'),
            behavior: SnackBarBehavior.floating,
            action: SnackBarAction(
              label: 'View',
              onPressed: () => context.push('/library/${list.id}', extra: list),
            ),
          ),
        );

        widget.onAdded?.call();
      }
    } catch (e, stack) {
      _logger.severe('Error adding to list', e, stack);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to add to list'),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  Future<void> _removeFromList(
      BuildContext context, String itemId, ListModel list) async {
    try {
      setState(() => _isLoading = true);
      await AppPocketBaseService.instance.engine.listService
          .removeListItem(list.id, itemId);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Removed from ${list.name}'),
            behavior: SnackBarBehavior.floating,
          ),
        );
        widget.onRemoved?.call();
      }

      setState(() {
        _existsInList = false;
        _existingItemId = null;
        _isLoading = false;
      });
    } catch (e) {
      _logger.severe('Error removing from list', e);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to remove from list'),
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
      setState(() => _isLoading = false);
    }
  }

  Future<void> _showListsDialog(BuildContext context) async {
    await _loadLists();
    if (!mounted) return;

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add to List'),
        content: SizedBox(
          width: double.maxFinite,
          height: MediaQuery.of(context).size.height * 0.4,
          child: _isLoading
              ? const Center(
                  child: CircularProgressIndicator(),
                )
              : _lists.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.folder_outlined,
                            size: 48,
                            color: colorScheme.primary.withAlpha(150),
                          ),
                          const SizedBox(height: 16),
                          Text(
                            'No Lists Yet',
                            style: theme.textTheme.titleLarge,
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'Create a list to start organizing',
                            style: theme.textTheme.bodyLarge?.copyWith(
                              color: colorScheme.onSurface.withAlpha(150),
                            ),
                            textAlign: TextAlign.center,
                          ),
                          const SizedBox(height: 24),
                          FilledButton.icon(
                            onPressed: () {
                              Navigator.pop(context);
                              context.push('/library/create');
                            },
                            icon: const Icon(Icons.add),
                            label: const Text('Create New List'),
                          ),
                        ],
                      ),
                    )
                  : ListView.separated(
                      itemCount: _lists.length,
                      separatorBuilder: (context, index) =>
                          const Divider(height: 1),
                      itemBuilder: (context, index) {
                        final list = _lists[index];
                        return ListTile(
                          leading: Icon(
                            _getListIcon(list.name),
                            color: colorScheme.primary,
                          ),
                          title: Text(list.name),
                          subtitle: list.description.isNotEmpty
                              ? Text(
                                  list.description,
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                )
                              : null,
                          onTap: () async {
                            Navigator.pop(context);
                            await _addToList(context, list);
                          },
                        );
                      },
                    ),
        ),
        contentPadding: _isLoading || _lists.isEmpty
            ? const EdgeInsets.all(24)
            : const EdgeInsets.symmetric(vertical: 8),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (widget.listName != null) {
      final icon = _getListIcon(widget.listName!);

      // Minimal mode UI
      if (widget.minimal) {
        return IconButton(
          onPressed: _isLoading
              ? null
              : () {
                  if (_existsInList &&
                      _existingItemId != null &&
                      _existingList != null) {
                    _removeFromList(context, _existingItemId!, _existingList!);
                  } else {
                    _createAndAddToList(context, widget.listName!);
                  }
                },
          icon: _isLoading
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                )
              : Icon(
                  _existsInList
                      ? _getListIconUnselected(widget.listName!)
                      : icon,
                  color: _existsInList
                      ? widget.listName?.toLowerCase() == 'favourites'
                          ? Colors.red
                          : colorScheme.primary
                      : colorScheme.onSurfaceVariant,
                ),
          style: IconButton.styleFrom(
            backgroundColor: _existsInList
                ? widget.listName?.toLowerCase() == 'favourites'
                    ? Colors.red.withOpacity(0.1)
                    : colorScheme.primary.withOpacity(0.1)
                : null,
          ),
        );
      }

      // Original UI for non-minimal mode
      return ElevatedButton.icon(
        onPressed: _isLoading
            ? null
            : () {
                if (_existsInList &&
                    _existingItemId != null &&
                    _existingList != null) {
                  _removeFromList(context, _existingItemId!, _existingList!);
                } else {
                  _createAndAddToList(context, widget.listName!);
                }
              },
        icon: _isLoading
            ? const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                ),
              )
            : Icon(
                _existsInList
                    ? Icons.remove_circle_outline
                    : _getListIcon(widget.listName!),
              ),
        label: Text(
          _isLoading
              ? _existsInList
                  ? 'Removing...'
                  : 'Adding...'
              : _existsInList
                  ? 'Remove from ${widget.listName}'
                  : 'Add to ${widget.listName}',
        ),
        style: ElevatedButton.styleFrom(
          backgroundColor: _existsInList ? colorScheme.errorContainer : null,
          foregroundColor: _existsInList ? colorScheme.onErrorContainer : null,
        ),
      );
    }

    if (widget.useDialog) {
      return InkWell(
        onTap: () => _showListsDialog(context),
        child: widget.child ?? Icon(widget.icon ?? Icons.playlist_add),
      );
    }

    return MenuAnchor(
      builder: (context, controller, child) {
        return widget.child ??
            (widget.label != null
                ? ElevatedButton(
                    onPressed: () {
                      _loadLists();
                      controller.open();
                    },
                    child: widget.label,
                  )
                : IconButton(
                    icon: Icon(widget.icon ?? Icons.playlist_add),
                    onPressed: () {
                      _loadLists();
                      controller.open();
                    },
                  ));
      },
      menuChildren: [
        if (_isLoading)
          const MenuItemButton(
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                ),
                SizedBox(width: 8),
                Text('Loading lists...'),
              ],
            ),
          )
        else if (_lists.isEmpty)
          MenuItemButton(
            onPressed: () => context.push('/library/create'),
            child: const Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.add),
                SizedBox(width: 8),
                Text('Create new list'),
              ],
            ),
          )
        else
          for (final list in _lists)
            MenuItemButton(
              onPressed: () => _addToList(context, list),
              leadingIcon: Icon(
                _getListIcon(list.name),
                size: 18,
              ),
              child: _getListIcon(list.name) == Icons.folder_outlined
                  ? Text(list.name)
                  : null,
            ),
      ],
    );
  }

  IconData _getListIconUnselected(String name) {
    switch (name.toLowerCase()) {
      case 'watchlist':
        return Icons.bookmark;
      case 'favourites':
        return Icons.favorite;
      case 'watch later':
        return Icons.watch_later;
      default:
        return Icons.folder;
    }
  }

  IconData _getListIcon(String name) {
    switch (name.toLowerCase()) {
      case 'watchlist':
        return Icons.bookmark_add_outlined;
      case 'favourites':
        return Icons.favorite_outline;
      case 'watch later':
        return Icons.watch_later_outlined;
      default:
        return Icons.folder_outlined;
    }
  }
}
